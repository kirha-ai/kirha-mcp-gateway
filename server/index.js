import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const server = new McpServer({
  name: "kirha-mcp-gateway",
  version: "1.0.0",
});

const KIRHA_API_KEY = process.env.KIRHA_API_KEY;
const TOOL_PLAN_MODE_ENABLED = process.env.TOOL_PLAN_MODE_ENABLED === "true" ?? false;
const VERTICAL_ID = process.env.VERTICAL_ID;

const toolsMetadataByVertical = {
  crypto: {
    createToolPlanning: {
      name: "create-crypto-tool-planning",
      title: "Prepare a crypto-related question",
      description: `
        This tool allows you to prepare and create a plan for any crypto-related question. 
        It returns a plan_id that can later be used to execute the plan and retrieve the detailed results.
        Important: For crypto-related topics, you should always use this tool before doing a search or using the execution tool. 
        This ensures you get the most accurate, pre-validated results.
      `,
    },
    executePlanToolPlanning: {
      name: "execute-crypto-tool-planning",
      title: "Execute a plan about crypto currency",
      description: `
        This tool takes a plan_id (previously generated by the create-crypto-tool-planning tool).
        It will executes it to provide a detailed answer about your crypto-related question.
      `,
    },
    executeAutoToolPlanning: {
      name: "execute-crypto-tool-planning",
      title: "Enrich your crypto-related question with a detailed answer",
      description: `
        This tool automatically handles your cryptocurrency-related question. 
        Simply provide your question, and it will return a detailed answer after performing its internal analysis.
        Important: For crypto-related topics, you should always use this tool before doing a search or using the execution tool. 
        This ensures you get the most accurate, pre-validated results.
      `,
    },
  },
};

const toolsMetadata = toolsMetadataByVertical[VERTICAL_ID];

if (!toolsMetadata) {
  throw new Error("Selected vertical not supported yet");
}

const headers = {
  "Content-Type": "application/json",
  Authorization: `Bearer ${KIRHA_API_KEY}`,
};

const kirhaApiUrl = "https://api.kirha.ai/chat/v1";
const createToolPlanningUrl = `${kirhaApiUrl}/tool-planning`;
const executeToolPlanningUrl = `${kirhaApiUrl}/tool-planning/execute`;

function createToolPlanning(query) {
  return fetch(createToolPlanningUrl, {
    method: "POST",
    body: JSON.stringify({
      query,
      vertical_id: VERTICAL_ID,
    }),
    headers,
  })
    .then((res) => res.json())
    .then((res) => {
      return { content: [{ type: "text", text: JSON.stringify(res) }] };
    });
}

function executeToolPlanningPlanMode(plan_id) {
  return fetch(executeToolPlanningUrl, {
    method: "POST",
    body: JSON.stringify({
      mode: "plan",
      plan_id,
      summarization: { enable: true, model: "kirha-flash" },
    }),
    headers,
  })
    .then((res) => res.json())
    .then((res) => {
      return { content: [{ type: "text", text: JSON.stringify(res) }] };
    });
}

function executeToolPlanningAutoMode(query) {
  return fetch(executeToolPlanningUrl, {
    method: "POST",
    body: JSON.stringify({
      mode: "auto",
      query,
      vertical_id: VERTICAL_ID,
      summarization: { enable: true, model: "kirha-flash" },
    }),
    headers,
  })
    .then((res) => res.json())
    .then((res) => {
      return { content: [{ type: "text", text: JSON.stringify(res) }] };
    });
}

if (TOOL_PLAN_MODE_ENABLED) {
  server.registerTool(
    toolsMetadata.createToolPlanning.name,
    {
      title: toolsMetadata.createToolPlanning.title,
      description: toolsMetadata.createToolPlanning.description,
      inputSchema: { prompt_query: z.string() },
    },
    ({ prompt_query }) => createToolPlanning(prompt_query),
  );

  server.registerTool(
    toolsMetadata.executePlanToolPlanning.name,
    {
      title: toolsMetadata.executePlanToolPlanning.title,
      description: toolsMetadata.executePlanToolPlanning.description,
      inputSchema: { plan_id: z.string() },
    },
    async ({ plan_id }) => executeToolPlanningPlanMode(plan_id),
  );
} else {
  server.registerTool(
    toolsMetadata.executeAutoToolPlanning.name,
    {
      title: toolsMetadata.executeAutoToolPlanning.title,
      description: toolsMetadata.executeAutoToolPlanning.description,
      inputSchema: { prompt_query: z.string() },
    },
    async ({ prompt_query }) => executeToolPlanningAutoMode(prompt_query),
  );
}

const transport = new StdioServerTransport();
server.connect(transport);
